import { promises as fs } from 'fs';
import { join } from 'path';
import { spawn } from 'child_process';
import { promisify } from 'util';

export interface GitCommitConfig {
  autoCommit: boolean;
  commitMessage?: string;
  enforceRule: boolean;
  documentTypes: string[];
}

export class GitCommitEnforcer {
  private config: GitCommitConfig;
  private projectRoot: string;

  constructor(projectRoot: string = process.cwd(), config: Partial<GitCommitConfig> = {}) {
    this.projectRoot = projectRoot;
    this.config = {
      autoCommit: true,
      enforceRule: true,
      documentTypes: ['instruction', 'report', 'learning', 'handoff', 'pattern'],
      ...config
    };
  }

  /**
   * Execute git commit with enhanced rules
   */
  async executeCommitWithRule(
    type: 'instruction' | 'report' | 'learning' | 'handoff' | 'pattern' | 'general',
    description: string,
    files: string[] = []
  ): Promise<boolean> {
    try {
      // 1. Git status check
      const hasChanges = await this.checkGitChanges();
      if (!hasChanges && files.length === 0) {
        console.log('‚ÑπÔ∏è No changes to commit');
        return true;
      }

      // 2. Stage files
      if (files.length > 0) {
        await this.stageFiles(files);
      } else {
        await this.stageFiles(['docs/']);
      }

      // 3. Generate commit message
      const commitMessage = this.generateCommitMessage(type, description);

      // 4. Execute commit
      await this.gitCommit(commitMessage);

      console.log(`‚úÖ Git commit completed: ${type} - ${description}`);
      return true;

    } catch (error) {
      console.error(`‚ùå Git commit failed: ${error instanceof Error ? error.message : error}`);
      return false;
    }
  }

  /**
   * Check if documentation creation requires git commit
   */
  detectDocumentationChanges(todos: any[]): { requiresCommit: boolean; detectedTypes: string[] } {
    const detectedTypes: string[] = [];

    for (const todo of todos) {
      for (const docType of this.config.documentTypes) {
        if (todo.content.toLowerCase().includes(docType)) {
          detectedTypes.push(docType);
        }
      }
    }

    return {
      requiresCommit: detectedTypes.length > 0,
      detectedTypes: [...new Set(detectedTypes)]
    };
  }

  /**
   * Automatically add git commit todo if documentation detected
   */
  addGitCommitTodoIfNeeded(todos: any[]): any[] {
    const detection = this.detectDocumentationChanges(todos);

    if (!detection.requiresCommit || !this.config.enforceRule) {
      return todos;
    }

    // Check if git commit todo already exists
    const hasGitCommitTodo = todos.some(todo =>
      todo.content.toLowerCase().includes('git commit')
    );

    if (!hasGitCommitTodo) {
      // Add git commit todo at the end
      const gitCommitTodo = {
        content: `Git commit ${detection.detectedTypes.join(', ')} documentation`,
        activeForm: `Committing ${detection.detectedTypes.join(', ')} documentation`,
        status: "pending"
      };

      todos.push(gitCommitTodo);

      console.log(`üîÑ Auto-added git commit todo for: ${detection.detectedTypes.join(', ')}`);
    }

    return todos;
  }

  /**
   * Generate enhanced commit message
   */
  private generateCommitMessage(type: string, description: string): string {
    const typeMap: Record<string, string> = {
      instruction: 'docs(instruction)',
      report: 'docs(report)',
      learning: 'docs(learning)',
      handoff: 'docs(handoff)',
      pattern: 'docs(pattern)',
      general: 'docs'
    };

    const prefix = typeMap[type] || 'docs';
    const timestamp = new Date().toISOString().slice(0, 16).replace('T', ' ');

    return `${prefix}: ${description}

Auto-generated by enhanced-cc-sdd git commit enforcer
Timestamp: ${timestamp}

ü§ñ Generated with Claude Code

Co-Authored-By: Claude <noreply@anthropic.com>`;
  }

  /**
   * Check if there are git changes
   */
  private async checkGitChanges(): Promise<boolean> {
    try {
      const result = await this.execCommand('git status --porcelain');
      return result.trim().length > 0;
    } catch (error) {
      return false;
    }
  }

  /**
   * Stage specific files
   */
  private async stageFiles(files: string[]): Promise<void> {
    for (const file of files) {
      try {
        await this.execCommand(`git add ${file}`);
      } catch (error) {
        console.warn(`‚ö†Ô∏è Could not stage ${file}: ${error instanceof Error ? error.message : error}`);
      }
    }
  }

  /**
   * Execute git commit
   */
  private async gitCommit(message: string): Promise<void> {
    const escapedMessage = message.replace(/"/g, '\\"');
    await this.execCommand(`git commit -m "${escapedMessage}"`);
  }

  /**
   * Execute shell command
   */
  private async execCommand(command: string): Promise<string> {
    return new Promise((resolve, reject) => {
      const [cmd, ...args] = command.split(' ');
      const child = spawn(cmd, args, {
        cwd: this.projectRoot,
        stdio: ['pipe', 'pipe', 'pipe']
      });

      let stdout = '';
      let stderr = '';

      child.stdout.on('data', (data) => {
        stdout += data.toString();
      });

      child.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      child.on('close', (code) => {
        if (code === 0) {
          resolve(stdout);
        } else {
          reject(new Error(`Command failed (${code}): ${stderr || stdout}`));
        }
      });

      child.on('error', (error) => {
        reject(error);
      });
    });
  }

  /**
   * Validate git repository
   */
  async validateGitRepository(): Promise<boolean> {
    try {
      await this.execCommand('git rev-parse --git-dir');
      return true;
    } catch (error) {
      console.error('‚ùå Not a git repository or git not available');
      return false;
    }
  }

  /**
   * Get git commit configuration
   */
  getConfig(): GitCommitConfig {
    return { ...this.config };
  }

  /**
   * Update configuration
   */
  updateConfig(newConfig: Partial<GitCommitConfig>): void {
    this.config = { ...this.config, ...newConfig };
  }
}